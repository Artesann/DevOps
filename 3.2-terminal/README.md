1. cd is a shell builtin. Думаю выносить ее как отдельную программу было бы не безопасно или невозможно, так как данная команда меняет текущую директорию процесса.
2. grep -c
3. /sbin/init
4. ls 2>/dev/pts/1
5. sed 's/hello/world/' 0<input.txt 1>output.txt
6. Можно echo hello > /dev/tty1. Если есть монитор на котором открыт tty1, то там появится hello.
7. Создается дескриптор с номером 5, который указывает на тот же файл, что и дескриптор 1 (stdout).
8. ll -e 3>&1 1>&2 2>&3 | grep invalid можно так. Флага -e не существует и текст ошибки пойдет в grep. Если убрать флаг, на вход grep ничего не пойдет.
9. Выведет переменные окружения, похожий вывод можно получить командой printenv.
10. /proc/[pid]/exe - символьная ссылка на исполняемый файл. /proc/[pid]/cmdline содержит команду, которой был запущен процесс
11. sse4_2
12. Возможно потому что команда `tty` выполняется без привязки к какому либо терминалу, она возвращает `not a tty`. Можно принудительно создать псевдо-терминал с помощью флага `ssh -t`
13. На ubuntu нужно было в /etc/sysctl.d/10-ptrace.conf поменять setkernel.yama.ptrace_scope to 0
14. Вроде все просто `tee - read from standard input and write to standard output and files`. В первом случае у `bash`, который выполняет запись в файл, нет прав на запись. А с помощью `sudo tee` мы запускаем `tee` с привилегиями на запись.

